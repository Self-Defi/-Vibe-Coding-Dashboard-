/* templates.js
   Vibe Coding — Industry Templates (Phases 1–5 engine)
   - Stage 3 proof repos are ALWAYS static GitHub files (index.html / styles.css / app.js / data/*.csv).
   - Stage 4 Source-of-Truth defaults are auto-generated by industry archetype.
   - Stage 5 snapshot is built from the same truth inputs.

   Industries included:
   Finance, Healthcare, Education, Non-profits, Construction, Small Business, Supply Chain
*/

// -------------------------
// Shared helpers
// -------------------------
function makeProofHTML({ title, subtitle, pills = [], tableTitle, tableSubtitle, columns, rightPanelTitle, rightPanelBlocks, footer }) {
  const pillHtml = pills.map(p => `<span class="pill ${p.kind || ""}" id="${p.id}">${p.label}: —</span>`).join("");
  const ths = columns.map(c => `<th>${c}</th>`).join("");

  // Right panel blocks can be KPI grid + lists + rules
  const rightHtml = rightPanelBlocks.join("\n");

  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>${title}</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="top">
    <div>
      <h1>${title}</h1>
      <p class="muted">${subtitle}</p>
    </div>
    <div class="pillRow">
      ${pillHtml}
    </div>
  </header>

  <main class="grid">
    <section class="card">
      <h2>${tableTitle}</h2>
      <p class="muted">${tableSubtitle}</p>
      <div class="tableWrap">
        <table id="mainTable">
          <thead><tr>${ths}</tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="card">
      <h2>${rightPanelTitle}</h2>
      ${rightHtml}
    </section>
  </main>

  <footer class="foot">${footer}</footer>
  <script src="app.js"></script>
</body>
</html>`;
}

function makeKPIGrid(idsAndLabels) {
  const items = idsAndLabels.map(x => `
    <div class="kpi">
      <div class="kpiLabel">${x.label}</div>
      <div class="kpiValue" id="${x.id}">—</div>
    </div>`).join("");

  return `<div class="kpis">${items}</div>`;
}

function makeListBlock({ title, id }) {
  return `<h3>${title}</h3><ul id="${id}" class="list"></ul>`;
}

function makeRulesBlock(lines) {
  const li = lines.map(l => `<li>${l}</li>`).join("");
  return `<h3>Rules (Proof)</h3><ul class="list">${li}</ul>`;
}

function baseCSVParserJS(csvPathVarName = "CSV_PATH") {
  return `
function parseCSV(t){
  const l=t.trim().split(/\\r?\\n/);
  const h=l[0].split(",").map(s=>s.trim());
  return l.slice(1).map(line=>{
    const c=line.split(",").map(s=>s.trim());
    const r={}; h.forEach((k,i)=>r[k]=c[i]??"");
    return r;
  });
}
function setText(id,v){const el=document.getElementById(id); if(el) el.textContent=v;}
function groupCount(rows,key){
  const m=new Map();
  for(const r of rows){
    const k=(r[key]||"Unknown").trim()||"Unknown";
    m.set(k,(m.get(k)||0)+1);
  }
  return [...m.entries()].sort((a,b)=>b[1]-a[1]);
}
function renderList(id,entries){
  const ul=document.getElementById(id);
  if(!ul) return;
  ul.innerHTML="";
  for(const [k,v] of entries){
    const li=document.createElement("li");
    li.textContent=\`\${k}: \${v}\`;
    ul.appendChild(li);
  }
}
function renderTable(tbodySelector, rows, cols){
  const tb=document.querySelector(tbodySelector);
  tb.innerHTML="";
  for(const r of rows){
    const tr=document.createElement("tr");
    for(const c of cols){
      const td=document.createElement("td");
      td.textContent = (r[c] ?? "").toString() || "—";
      tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
}
`;
}

const BASE_PROOF_STYLES_CSS = `:root{
  --bg:#0b1220; --card:rgba(255,255,255,.06); --border:rgba(255,255,255,.10);
  --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.65);
  --good:#16a34a; --warn:#f59e0b; --bad:#ef4444; --radius:14px;
}
*{box-sizing:border-box}
body{
  margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
  background: radial-gradient(1200px 700px at 20% 10%, rgba(76,29,149,.35), transparent 60%),
              radial-gradient(1200px 700px at 90% 30%, rgba(2,132,199,.25), transparent 55%), var(--bg);
}
.top{padding:20px 18px; display:flex; justify-content:space-between; gap:16px; border-bottom:1px solid var(--border)}
h1{margin:0 0 6px 0; font-size:20px}
h2{margin:0 0 6px 0; font-size:16px}
h3{margin:14px 0 6px 0; font-size:14px}
.muted{margin:0; color:var(--muted); font-size:13px}
.pillRow{display:flex; gap:8px; flex-wrap:wrap}
.pill{padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,.04); font-size:12px}
.pill.good{border-color:rgba(22,163,74,.6); background:rgba(22,163,74,.10)}
.pill.warn{border-color:rgba(245,158,11,.6); background:rgba(245,158,11,.10)}
.pill.bad{border-color:rgba(239,68,68,.6); background:rgba(239,68,68,.10)}
.grid{padding:18px; display:grid; gap:14px; grid-template-columns: 1.4fr 1fr}
@media (max-width:980px){.grid{grid-template-columns:1fr}}
.card{border:1px solid var(--border); background:var(--card); border-radius:var(--radius); padding:14px; backdrop-filter: blur(10px)}
.tableWrap{overflow:auto; border-radius:12px; border:1px solid var(--border)}
table{width:100%; border-collapse:collapse; min-width:860px}
th,td{padding:10px; border-bottom:1px solid var(--border); font-size:12px; text-align:left}
th{position:sticky; top:0; background:rgba(11,18,32,.9)}
.kpis{display:grid; grid-template-columns:repeat(2,1fr); gap:10px; margin-top:8px}
.kpi{border:1px solid var(--border); border-radius:12px; padding:10px; background:rgba(255,255,255,.03)}
.kpiLabel{color:var(--muted); font-size:12px}
.kpiValue{font-size:18px; margin-top:4px}
.list{margin:8px 0 0 0; padding-left:18px; color:rgba(255,255,255,.85)}
.foot{padding:14px 18px; color:var(--muted); font-size:12px; border-top:1px solid var(--border)}`;

// -------------------------
// SUPPLY CHAIN (existing archetype)
// -------------------------
const SUPPLYCHAIN_PROOF_CSV =
`shipment_id,po,carrier,supplier,status,planned_delivery,actual_delivery,handoff_point
SHP-1001,PO-7781,FedEx,SupplierA,In Transit,2026-01-01,,Carrier
SHP-1002,PO-7782,UPS,SupplierB,Delivered,2025-12-29,2026-01-02,Warehouse
SHP-1003,PO-7783,DHL,SupplierA,Delayed,2026-01-01,,Customs
SHP-1004,PO-7784,FedEx,SupplierC,Delivered,2026-01-03,2026-01-03,Carrier
SHP-1005,PO-7785,UPS,SupplierB,Delayed,2026-01-02,,Warehouse`;

const SUPPLYCHAIN_PROOF_INDEX_HTML = makeProofHTML({
  title: "Delay Visibility — Proof v1",
  subtitle: "Reads a CSV export and flags late shipments. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Shipments" },
    { id:"lateCount", label:"Late", kind:"bad" }
  ],
  tableTitle: "Top Late Shipments",
  tableSubtitle: "Sorted by days late (highest first).",
  columns: ["Shipment","PO","Supplier","Carrier","Status","Planned","Actual","Days Late","Handoff"],
  rightPanelTitle: "Delay Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"onTimePct", label:"On-time %"},
      {id:"avgLate", label:"Avg Days Late"},
      {id:"worstSupplier", label:"Worst Supplier"},
      {id:"worstHandoff", label:"Worst Handoff"},
    ]),
    makeListBlock({title:"Late by Supplier", id:"lateBySupplier"}),
    makeListBlock({title:"Late by Handoff Point", id:"lateByHandoff"}),
  ],
  footer: "Proof v1 = CSV → metrics → visible bottleneck in <60 seconds."
});

const SUPPLYCHAIN_PROOF_APP_JS = `const CSV_PATH="data/shipments.csv";
${baseCSVParserJS()}
function daysBetween(a,b){a=new Date(a);b=new Date(b);return Math.floor((b-a)/(1000*60*60*24));}
function computeDaysLate(r,today){
  const p=r.planned_delivery;
  if(!p) return 0;
  const end = (r.actual_delivery && r.actual_delivery.length) ? r.actual_delivery : today;
  const diff = daysBetween(p,end);
  return diff>0?diff:0;
}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  for(const r of rows) r.days_late = computeDaysLate(r,todayISO);

  const late = rows.filter(r=>r.days_late>0).sort((a,b)=>b.days_late-a.days_late);

  setText("asOf", "As of: " + todayISO);
  setText("totalCount", "Shipments: " + rows.length);
  setText("lateCount", "Late: " + late.length);

  const onTime = rows.length ? ((rows.length-late.length)/rows.length)*100 : 0;
  setText("onTimePct", Math.round(onTime) + "%");
  const avgLate = late.length ? (late.reduce((s,r)=>s+r.days_late,0)/late.length) : 0;
  setText("avgLate", avgLate.toFixed(1));

  const bySupplier = groupCount(late, "supplier");
  const byHandoff = groupCount(late, "handoff_point");

  setText("worstSupplier", bySupplier[0] ? (bySupplier[0][0] + " (" + bySupplier[0][1] + ")") : "—");
  setText("worstHandoff", byHandoff[0] ? (byHandoff[0][0] + " (" + byHandoff[0][1] + ")") : "—");

  renderList("lateBySupplier", bySupplier);
  renderList("lateByHandoff", byHandoff);

  const tableRows = late.map(r => ({
    Shipment: r.shipment_id, PO:r.po, Supplier:r.supplier, Carrier:r.carrier, Status:r.status,
    Planned:r.planned_delivery||"—", Actual:r.actual_delivery||"—", "Days Late": String(r.days_late),
    Handoff:r.handoff_point||"—"
  }));
  renderTable("#mainTable tbody", tableRows.slice(0,25), ["Shipment","PO","Supplier","Carrier","Status","Planned","Actual","Days Late","Handoff"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/shipments.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// EDUCATION
// -------------------------
const EDUCATION_PROOF_CSV =
`student_id,student_name,class,current_grade,missing_assignments,attendance_rate,last_updated
STU-1001,Ava Johnson,Algebra,82,1,94,2026-01-05
STU-1002,Noah Lee,Algebra,68,4,88,2026-01-05
STU-1003,Mia Patel,English,75,2,92,2026-01-05
STU-1004,Ethan Chen,English,89,0,97,2026-01-05
STU-1005,Sophia Rivera,History,64,5,85,2026-01-05`;

const EDUCATION_PROOF_INDEX_HTML = makeProofHTML({
  title: "Student Progress — Proof v1",
  subtitle: "Reads a gradebook CSV and ranks intervention priority. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Students" },
    { id:"criticalCount", label:"Critical", kind:"bad" }
  ],
  tableTitle: "Top Intervention Priority",
  tableSubtitle: "Sorted by priority score (highest first).",
  columns: ["Student","Class","Grade","Missing","Attendance","Status","Priority"],
  rightPanelTitle: "Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"onTrack", label:"On Track"},
      {id:"atRisk", label:"At Risk"},
      {id:"critical", label:"Critical"},
      {id:"avgGrade", label:"Avg Grade"}
    ]),
    makeRulesBlock([
      "On Track: grade ≥ 80 AND missing ≤ 1",
      "At Risk: grade 70–79 OR missing 2–3",
      "Critical: grade < 70 OR missing ≥ 4"
    ])
  ],
  footer: "Proof v1 = CSV → ranking → intervention clarity in <60 seconds."
});

const EDUCATION_PROOF_APP_JS = `const CSV_PATH="data/students.csv";
${baseCSVParserJS()}
function statusFor(grade,missing){
  if(grade>=80 && missing<=1) return "On Track";
  if(grade<70 || missing>=4) return "Critical";
  return "At Risk";
}
function priorityScore(grade,missing,att){
  const g = Math.max(0, 100 - grade);
  const m = missing * 18;
  const a = (att!==null) ? Math.max(0, 95 - att) : 0;
  return Math.round(g + m + a);
}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  for(const r of rows){
    const grade = Number(r.current_grade);
    const missing = Number(r.missing_assignments);
    const att = r.attendance_rate?.length ? Number(r.attendance_rate) : null;
    r.status = statusFor(grade,missing);
    r.priority = priorityScore(grade,missing,att);
  }

  rows.sort((a,b)=>b.priority-a.priority);

  setText("asOf", "As of: " + todayISO);
  setText("totalCount", "Students: " + rows.length);

  const onTrack=rows.filter(r=>r.status==="On Track").length;
  const atRisk=rows.filter(r=>r.status==="At Risk").length;
  const critical=rows.filter(r=>r.status==="Critical").length;

  setText("criticalCount", "Critical: " + critical);
  setText("onTrack", String(onTrack));
  setText("atRisk", String(atRisk));
  setText("critical", String(critical));

  const avg=rows.reduce((s,r)=>s+Number(r.current_grade||0),0)/Math.max(1,rows.length);
  setText("avgGrade", avg.toFixed(1));

  const tableRows = rows.map(r => ({
    Student: r.student_name, Class: r.class, Grade: r.current_grade,
    Missing: r.missing_assignments, Attendance: r.attendance_rate||"—",
    Status: r.status, Priority: String(r.priority)
  }));
  renderTable("#mainTable tbody", tableRows.slice(0,25), ["Student","Class","Grade","Missing","Attendance","Status","Priority"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/students.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// FINANCE (portfolio + compliance + custody dashboard archetype)
// -------------------------
const FINANCE_PROOF_CSV =
`account_id,owner,asset,amount,usd_value,risk_level,compliance_flag,last_updated
ACC-1001,Treasury,BTC,1.25,55000,Low,OK,2026-01-05
ACC-1002,Treasury,ETH,22,48000,Medium,OK,2026-01-05
ACC-1003,Ops,USDC,12000,12000,Low,OK,2026-01-05
ACC-1004,Treasury,ALT,50000,9000,High,REVIEW,2026-01-05
ACC-1005,Ops,USDT,4000,4000,Medium,REVIEW,2026-01-05`;

const FINANCE_PROOF_INDEX_HTML = makeProofHTML({
  title: "Treasury Visibility — Proof v1",
  subtitle: "Reads a CSV export and flags risk/compliance exceptions. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Positions" },
    { id:"reviewCount", label:"Review", kind:"warn" }
  ],
  tableTitle: "Top Exceptions",
  tableSubtitle: "Sorted by USD value (highest first) and compliance flag.",
  columns: ["Account","Owner","Asset","USD Value","Risk","Compliance","Last Updated"],
  rightPanelTitle: "Treasury Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"totalUSD", label:"Total USD"},
      {id:"highRiskUSD", label:"High Risk USD"},
      {id:"reviewUSD", label:"Review USD"},
      {id:"topAsset", label:"Top Asset"}
    ]),
    makeListBlock({title:"Exceptions by Owner", id:"byOwner"}),
    makeRulesBlock([
      "REVIEW = compliance_flag != OK",
      "High Risk = risk_level == High",
      "Proof does not connect wallets/exchanges yet"
    ])
  ],
  footer: "Proof v1 = CSV → exceptions → visible risk/compliance in <60 seconds."
});

const FINANCE_PROOF_APP_JS = `const CSV_PATH="data/treasury.csv";
${baseCSVParserJS()}
function toNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  setText("asOf","As of: "+todayISO);
  setText("totalCount","Positions: "+rows.length);

  const withUSD = rows.map(r => ({...r, usd: toNum(r.usd_value)}));
  const review = withUSD.filter(r => (r.compliance_flag||"").toUpperCase()!=="OK");
  setText("reviewCount","Review: "+review.length);

  const totalUSD = withUSD.reduce((s,r)=>s+r.usd,0);
  const highRiskUSD = withUSD.filter(r=>r.risk_level==="High").reduce((s,r)=>s+r.usd,0);
  const reviewUSD = review.reduce((s,r)=>s+r.usd,0);

  setText("totalUSD", "$" + Math.round(totalUSD).toLocaleString());
  setText("highRiskUSD", "$" + Math.round(highRiskUSD).toLocaleString());
  setText("reviewUSD", "$" + Math.round(reviewUSD).toLocaleString());

  const top = [...withUSD].sort((a,b)=>b.usd-a.usd)[0];
  setText("topAsset", top ? (top.asset + " ($" + Math.round(top.usd).toLocaleString() + ")") : "—");

  const byOwner = groupCount(review, "owner");
  renderList("byOwner", byOwner);

  const exceptions = [...withUSD]
    .filter(r => r.risk_level==="High" || (r.compliance_flag||"").toUpperCase()!=="OK")
    .sort((a,b)=>b.usd-a.usd);

  const tableRows = exceptions.map(r=>({
    Account:r.account_id, Owner:r.owner, Asset:r.asset,
    "USD Value":"$"+Math.round(r.usd).toLocaleString(),
    Risk:r.risk_level, Compliance:r.compliance_flag, "Last Updated": r.last_updated || "—"
  }));

  renderTable("#mainTable tbody", tableRows.slice(0,25),
    ["Account","Owner","Asset","USD Value","Risk","Compliance","Last Updated"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/treasury.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// HEALTHCARE (intake + workflow optimization archetype)
// -------------------------
const HEALTHCARE_PROOF_CSV =
`case_id,patient,service,status,days_waiting,priority,owner,next_action,last_updated
CASE-2001,Patient A,Intake,Waiting,6,High,Front Desk,Call patient,2026-01-05
CASE-2002,Patient B,Lab,In Progress,2,Medium,Nurse,Follow up lab,2026-01-05
CASE-2003,Patient C,Intake,Waiting,9,High,Front Desk,Escalate intake,2026-01-05
CASE-2004,Patient D,Imaging,Scheduled,1,Low,Coordinator,Confirm appointment,2026-01-05
CASE-2005,Patient E,Intake,Waiting,4,Medium,Front Desk,Send forms,2026-01-05`;

const HEALTHCARE_PROOF_INDEX_HTML = makeProofHTML({
  title: "Intake Flow — Proof v1",
  subtitle: "Reads a CSV export and surfaces patient workflow bottlenecks. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Cases" },
    { id:"stuckCount", label:"Stuck", kind:"bad" }
  ],
  tableTitle: "Top Stuck Cases",
  tableSubtitle: "Sorted by days waiting (highest first).",
  columns: ["Case","Service","Status","Days Waiting","Priority","Owner","Next Action","Updated"],
  rightPanelTitle: "Flow Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"waitingHigh", label:"High Priority Waiting"},
      {id:"avgWait", label:"Avg Days Waiting"},
      {id:"worstStage", label:"Worst Stage"},
      {id:"worstOwner", label:"Worst Owner"}
    ]),
    makeListBlock({title:"Stuck by Service", id:"byService"}),
    makeRulesBlock([
      "Stuck = status == Waiting AND days_waiting >= 5",
      "High priority stuck cases are escalated first",
      "Proof uses anonymized names; production requires PHI controls"
    ])
  ],
  footer: "Proof v1 = CSV → bottleneck visibility → clear intervention in <60 seconds."
});

const HEALTHCARE_PROOF_APP_JS = `const CSV_PATH="data/intake.csv";
${baseCSVParserJS()}
function toNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  setText("asOf","As of: "+todayISO);
  setText("totalCount","Cases: "+rows.length);

  const norm = rows.map(r => ({...r, days: toNum(r.days_waiting)}));
  const stuck = norm.filter(r => r.status==="Waiting" && r.days>=5).sort((a,b)=>b.days-a.days);
  setText("stuckCount","Stuck: "+stuck.length);

  const highWaiting = norm.filter(r => r.status==="Waiting" && r.priority==="High").length;
  setText("waitingHigh", String(highWaiting));

  const avgWait = norm.length ? (norm.reduce((s,r)=>s+r.days,0)/norm.length) : 0;
  setText("avgWait", avgWait.toFixed(1));

  const byService = groupCount(stuck, "service");
  const byOwner = groupCount(stuck, "owner");
  setText("worstStage", byService[0] ? (byService[0][0] + " (" + byService[0][1] + ")") : "—");
  setText("worstOwner", byOwner[0] ? (byOwner[0][0] + " (" + byOwner[0][1] + ")") : "—");

  renderList("byService", byService);

  const tableRows = stuck.map(r=>({
    Case:r.case_id, Service:r.service, Status:r.status, "Days Waiting":String(r.days),
    Priority:r.priority, Owner:r.owner, "Next Action":r.next_action, Updated:r.last_updated||"—"
  }));

  renderTable("#mainTable tbody", tableRows.slice(0,25),
    ["Case","Service","Status","Days Waiting","Priority","Owner","Next Action","Updated"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/intake.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// NON-PROFITS (donor transparency + program reporting archetype)
// -------------------------
const NONPROFITS_PROOF_CSV =
`donation_id,donor,program,amount,status,days_to_ack,owner,last_updated
DON-3001,Donor A,STEM Lab,250,Received,7,Admin,2026-01-05
DON-3002,Donor B,Scholarships,500,Received,2,Admin,2026-01-05
DON-3003,Donor C,Food Program,100,Pending,0,Ops,2026-01-05
DON-3004,Donor D,Scholarships,1000,Received,12,Admin,2026-01-05
DON-3005,Donor E,STEM Lab,75,Received,9,Admin,2026-01-05`;

const NONPROFITS_PROOF_INDEX_HTML = makeProofHTML({
  title: "Donor Transparency — Proof v1",
  subtitle: "Reads a CSV export and flags acknowledgment/reporting bottlenecks. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Donations" },
    { id:"overdueCount", label:"Overdue Thanks", kind:"warn" }
  ],
  tableTitle: "Overdue Acknowledgments",
  tableSubtitle: "Sorted by days to acknowledge (highest first).",
  columns: ["Donation","Program","Amount","Status","Days to Ack","Owner","Updated"],
  rightPanelTitle: "Program Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"totalRaised", label:"Total Raised"},
      {id:"overdueRaised", label:"Overdue Amount"},
      {id:"topProgram", label:"Top Program"},
      {id:"worstOwner", label:"Worst Owner"}
    ]),
    makeListBlock({title:"Overdue by Program", id:"byProgram"}),
    makeRulesBlock([
      "Overdue = status == Received AND days_to_ack > 7",
      "Proof tracks transparency workflow, not fundraising strategy",
      "Production can add donor receipts + audit trails"
    ])
  ],
  footer: "Proof v1 = CSV → bottleneck visibility → donor ops clarity in <60 seconds."
});

const NONPROFITS_PROOF_APP_JS = `const CSV_PATH="data/donations.csv";
${baseCSVParserJS()}
function toNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  setText("asOf","As of: "+todayISO);
  setText("totalCount","Donations: "+rows.length);

  const norm = rows.map(r => ({...r, amt: toNum(r.amount), days: toNum(r.days_to_ack)}));
  const totalRaised = norm.reduce((s,r)=>s+r.amt,0);
  setText("totalRaised", "$"+Math.round(totalRaised).toLocaleString());

  const overdue = norm.filter(r => r.status==="Received" && r.days>7).sort((a,b)=>b.days-a.days);
  setText("overdueCount","Overdue Thanks: "+overdue.length);

  const overdueAmt = overdue.reduce((s,r)=>s+r.amt,0);
  setText("overdueRaised", "$"+Math.round(overdueAmt).toLocaleString());

  const byProgram = groupCount(overdue, "program");
  renderList("byProgram", byProgram);

  const byOwner = groupCount(overdue, "owner");
  setText("worstOwner", byOwner[0] ? (byOwner[0][0] + " (" + byOwner[0][1] + ")") : "—");

  const topProgram = [...norm].sort((a,b)=>b.amt-a.amt)[0];
  setText("topProgram", topProgram ? (topProgram.program + " ($" + Math.round(topProgram.amt).toLocaleString() + ")") : "—");

  const tableRows = overdue.map(r=>({
    Donation:r.donation_id, Program:r.program,
    Amount:"$"+Math.round(r.amt).toLocaleString(),
    Status:r.status, "Days to Ack":String(r.days),
    Owner:r.owner, Updated:r.last_updated||"—"
  }));

  renderTable("#mainTable tbody", tableRows.slice(0,25),
    ["Donation","Program","Amount","Status","Days to Ack","Owner","Updated"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/donations.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// CONSTRUCTION (project tracking + cost/compliance documentation archetype)
// -------------------------
const CONSTRUCTION_PROOF_CSV =
`task_id,project,phase,status,days_blocked,cost_variance,owner,next_step,last_updated
TSK-4001,Site A,Framing,Blocked,6,1200,PM,Resolve permit,2026-01-05
TSK-4002,Site A,Electrical,In Progress,0,300,Foreman,Schedule inspection,2026-01-05
TSK-4003,Site B,Foundation,Blocked,9,2500,PM,Order materials,2026-01-05
TSK-4004,Site B,Plumbing,In Progress,0,150,Foreman,Continue work,2026-01-05
TSK-4005,Site A,Permitting,Blocked,4,0,Admin,Submit docs,2026-01-05`;

const CONSTRUCTION_PROOF_INDEX_HTML = makeProofHTML({
  title: "Project Bottlenecks — Proof v1",
  subtitle: "Reads a CSV export and surfaces blocked work + cost variance. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Tasks" },
    { id:"blockedCount", label:"Blocked", kind:"bad" }
  ],
  tableTitle: "Top Blocked Tasks",
  tableSubtitle: "Sorted by days blocked (highest first).",
  columns: ["Task","Project","Phase","Status","Days Blocked","Cost Var","Owner","Next Step","Updated"],
  rightPanelTitle: "Build Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"blockedDaysAvg", label:"Avg Blocked Days"},
      {id:"totalVariance", label:"Total Variance"},
      {id:"worstPhase", label:"Worst Phase"},
      {id:"worstProject", label:"Worst Project"}
    ]),
    makeListBlock({title:"Blocked by Phase", id:"byPhase"}),
    makeRulesBlock([
      "Blocked = status == Blocked AND days_blocked > 0",
      "Variance is surfaced for visibility (proof does not enforce budgets)",
      "Production can link to compliance docs + approvals"
    ])
  ],
  footer: "Proof v1 = CSV → blocked visibility → operational clarity in <60 seconds."
});

const CONSTRUCTION_PROOF_APP_JS = `const CSV_PATH="data/projects.csv";
${baseCSVParserJS()}
function toNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  setText("asOf","As of: "+todayISO);
  setText("totalCount","Tasks: "+rows.length);

  const norm = rows.map(r => ({...r, blocked: toNum(r.days_blocked), var: toNum(r.cost_variance)}));
  const blocked = norm.filter(r => r.status==="Blocked" && r.blocked>0).sort((a,b)=>b.blocked-a.blocked);
  setText("blockedCount","Blocked: "+blocked.length);

  const avgBlocked = blocked.length ? (blocked.reduce((s,r)=>s+r.blocked,0)/blocked.length) : 0;
  setText("blockedDaysAvg", avgBlocked.toFixed(1));

  const totalVar = norm.reduce((s,r)=>s+r.var,0);
  setText("totalVariance", "$"+Math.round(totalVar).toLocaleString());

  const byPhase = groupCount(blocked, "phase");
  renderList("byPhase", byPhase);

  const byProject = groupCount(blocked, "project");
  setText("worstPhase", byPhase[0] ? (byPhase[0][0] + " (" + byPhase[0][1] + ")") : "—");
  setText("worstProject", byProject[0] ? (byProject[0][0] + " (" + byProject[0][1] + ")") : "—");

  const tableRows = blocked.map(r=>({
    Task:r.task_id, Project:r.project, Phase:r.phase, Status:r.status,
    "Days Blocked":String(r.blocked),
    "Cost Var":"$"+Math.round(r.var).toLocaleString(),
    Owner:r.owner, "Next Step":r.next_step, Updated:r.last_updated||"—"
  }));

  renderTable("#mainTable tbody", tableRows.slice(0,25),
    ["Task","Project","Phase","Status","Days Blocked","Cost Var","Owner","Next Step","Updated"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/projects.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// SMALL BUSINESS (CRM + internal ops automation archetype)
// -------------------------
const SMALLBIZ_PROOF_CSV =
`lead_id,company,stage,owner,days_in_stage,deal_value,next_action,last_updated
LEAD-5001,Acme Co,Qualified,Sales,7,12000,Send proposal,2026-01-05
LEAD-5002,Orbit LLC,Contacted,Sales,3,4500,Book call,2026-01-05
LEAD-5003,Northwind,Proposal,Sales,10,20000,Follow up,2026-01-05
LEAD-5004,Skyline Inc,Negotiation,Owner,5,35000,Finalize terms,2026-01-05
LEAD-5005,Pine Labs,Contacted,Sales,9,8000,Re-engage,2026-01-05`;

const SMALLBIZ_PROOF_INDEX_HTML = makeProofHTML({
  title: "Sales Pipeline — Proof v1",
  subtitle: "Reads a CSV export and flags stalled deals. No integrations yet.",
  pills: [
    { id:"asOf", label:"As of" },
    { id:"totalCount", label:"Leads" },
    { id:"stalledCount", label:"Stalled", kind:"warn" }
  ],
  tableTitle: "Top Stalled Deals",
  tableSubtitle: "Sorted by days in stage (highest first).",
  columns: ["Lead","Company","Stage","Days in Stage","Value","Owner","Next Action","Updated"],
  rightPanelTitle: "Pipeline Summary",
  rightPanelBlocks: [
    makeKPIGrid([
      {id:"totalValue", label:"Total Value"},
      {id:"stalledValue", label:"Stalled Value"},
      {id:"worstStage", label:"Worst Stage"},
      {id:"topDeal", label:"Top Deal"}
    ]),
    makeListBlock({title:"Stalled by Stage", id:"byStage"}),
    makeRulesBlock([
      "Stalled = days_in_stage >= 7 (adjust later)",
      "Proof helps visibility; production can automate follow-ups",
      "No CRM integrations in v1"
    ])
  ],
  footer: "Proof v1 = CSV → stalled visibility → next-step clarity in <60 seconds."
});

const SMALLBIZ_PROOF_APP_JS = `const CSV_PATH="data/leads.csv";
${baseCSVParserJS()}
function toNum(x){const n=Number(x); return Number.isFinite(n)?n:0;}
async function main(){
  const res=await fetch(CSV_PATH,{cache:"no-store"});
  const text=await res.text();
  const rows=parseCSV(text);

  const todayISO=(new Date()).toISOString().slice(0,10);
  setText("asOf","As of: "+todayISO);
  setText("totalCount","Leads: "+rows.length);

  const norm = rows.map(r => ({...r, days: toNum(r.days_in_stage), val: toNum(r.deal_value)}));
  const stalled = norm.filter(r => r.days>=7).sort((a,b)=>b.days-a.days);
  setText("stalledCount","Stalled: "+stalled.length);

  const totalValue = norm.reduce((s,r)=>s+r.val,0);
  const stalledValue = stalled.reduce((s,r)=>s+r.val,0);
  setText("totalValue","$"+Math.round(totalValue).toLocaleString());
  setText("stalledValue","$"+Math.round(stalledValue).toLocaleString());

  const byStage = groupCount(stalled, "stage");
  renderList("byStage", byStage);
  setText("worstStage", byStage[0] ? (byStage[0][0] + " (" + byStage[0][1] + ")") : "—");

  const topDeal = [...norm].sort((a,b)=>b.val-a.val)[0];
  setText("topDeal", topDeal ? (topDeal.company + " ($" + Math.round(topDeal.val).toLocaleString() + ")") : "—");

  const tableRows = stalled.map(r=>({
    Lead:r.lead_id, Company:r.company, Stage:r.stage, "Days in Stage":String(r.days),
    Value:"$"+Math.round(r.val).toLocaleString(),
    Owner:r.owner, "Next Action":r.next_action, Updated:r.last_updated||"—"
  }));

  renderTable("#mainTable tbody", tableRows.slice(0,25),
    ["Lead","Company","Stage","Days in Stage","Value","Owner","Next Action","Updated"]);
}
main().catch(e=>{console.error(e); alert("Failed to load data/leads.csv. Serve via GitHub Pages (not file://).");});`;


// -------------------------
// INDUSTRIES registry (consumed by your dashboard app.js)
// -------------------------
const INDUSTRIES = {
  "Finance": {
    id: "finance",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a treasury visibility dashboard for finance leads so they can see risk and compliance exceptions instantly.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a dashboard ranking exceptions and summarizing total exposure.",
      realityTest: "A stranger can open it and understand where risk is concentrated in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": FINANCE_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": FINANCE_PROOF_APP_JS,
      "data/treasury.csv": FINANCE_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Finance teams lack fast, consistent visibility into treasury risk and compliance exceptions across accounts.",
        primaryUser: "Finance Lead / Treasury Manager",
        secondaryUsers: "Compliance, Operations",
        artifactType: "Dashboard",
        description: "Summarize positions from CSV and flag high-risk + compliance review items.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Exceptions are visible without explanation",
          "Risk and compliance rules are explicit",
          "Total exposure is summarized",
          "Proof can be updated by replacing CSV"
        ]
      },
      data: {
        requiredFields: [
          ["account_id","Unique account/portfolio identifier","Y"],
          ["owner","Team or custodian owner","Y"],
          ["asset","Asset symbol","Y"],
          ["usd_value","USD value of position","Y"],
          ["risk_level","Low/Medium/High","Y"],
          ["compliance_flag","OK/REVIEW","Y"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Positions","Export from portfolio/custody system","Finance","Daily"],
          ["Compliance flag","Ruleset/manual review","Compliance","Daily/Weekly"]
        ],
        validityRules: [
          "usd_value must be numeric",
          "compliance_flag must be OK or REVIEW",
          "If last_updated stale (>14d), show warning in production"
        ]
      },
      workflow: {
        states: [
          ["OK","No exception"],
          ["Review","Compliance flag != OK"],
          ["Escalated","High risk or large exposure requires leadership"],
          ["Resolved","Reviewed and documented"]
        ],
        triggers: [
          ["Review Detected","compliance_flag == REVIEW","Add to exceptions list"],
          ["High Risk Exposure","risk_level == High","Escalate based on threshold"]
        ],
        ownership: [
          ["Initial review","Compliance","Finance Lead if needed"],
          ["Escalation","Finance Lead","CFO / Controller"],
          ["Final authority","CFO / Controller","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Daily export (proof)"],
          ["Security sensitivity","High (financial data)"],
          ["Access","Authorized users only"]
        ],
        nonGoals: [
          "No trading automation in v1",
          "No wallet/exchange integrations in v1",
          "No forecasting in proof"
        ]
      }
    })
  },

  "Healthcare": {
    id: "healthcare",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build an intake workflow visibility dashboard for clinic coordinators so they can see where patients are stuck and what to do next.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a ranked list of stuck cases and a summary of bottlenecks.",
      realityTest: "A coordinator can open it and see top stuck cases in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": HEALTHCARE_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": HEALTHCARE_PROOF_APP_JS,
      "data/intake.csv": HEALTHCARE_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Teams lack fast visibility into patient workflow bottlenecks, causing delays and missed follow-ups.",
        primaryUser: "Clinic Coordinator / Front Desk",
        secondaryUsers: "Nursing, Operations",
        artifactType: "Dashboard",
        description: "Rank stuck cases from CSV and highlight service/owner bottlenecks.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Stuck definition is explicit",
          "Top stuck cases are visible",
          "Bottleneck stage and owner are summarized",
          "Next action is visible for each stuck case"
        ]
      },
      data: {
        requiredFields: [
          ["case_id","Unique case identifier","Y"],
          ["service","Intake/Lab/Imaging/etc","Y"],
          ["status","Workflow status","Y"],
          ["days_waiting","Time in waiting","Y"],
          ["priority","Low/Medium/High","Y"],
          ["owner","Responsible owner/team","Y"],
          ["next_action","Immediate next step","Y"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Cases","Export from EHR/clinic tracker","Clinic Ops","Daily/Weekly"]
        ],
        validityRules: [
          "days_waiting must be numeric",
          "priority must be Low/Medium/High",
          "No PHI required for proof (use anonymized names)"
        ]
      },
      workflow: {
        states: [
          ["Waiting","Pending action"],
          ["In Progress","Actively worked"],
          ["Scheduled","Scheduled appointment"],
          ["Escalated","Overdue/high priority"],
          ["Resolved","Completed"]
        ],
        triggers: [
          ["Stuck","status==Waiting AND days_waiting>=5","Escalate list"],
          ["High Priority Waiting","priority==High AND status==Waiting","Top priority"]
        ],
        ownership: [
          ["Initial action","Front Desk/Coordinator","Ops lead if stuck"],
          ["Escalation","Ops lead","Clinical leadership"],
          ["Final authority","Clinical leadership","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Daily/Weekly export (proof)"],
          ["Privacy sensitivity","Very High (health data)"],
          ["Access","Staff-only + compliance required"]
        ],
        nonGoals: [
          "No diagnosis decision support",
          "No automated patient messaging in proof",
          "No EHR integrations in v1"
        ]
      }
    })
  },

  "Education": {
    id: "education",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a student progress visibility dashboard for teachers so they can see who is falling behind and what action to take.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export from a gradebook.",
      output: "The proof is done when it produces a dashboard showing priority-ranked students and a summary of risk.",
      realityTest: "A teacher can open it and identify top priorities in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": EDUCATION_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": EDUCATION_PROOF_APP_JS,
      "data/students.csv": EDUCATION_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Teachers lack fast, consistent visibility into student progress and intervention priorities.",
        primaryUser: "Teacher",
        secondaryUsers: "Advisor/Dean, Parent Liaison",
        artifactType: "Dashboard",
        description: "Summarize progress from CSV and rank intervention priority.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Top priority students are visible immediately",
          "At-risk rules are explicit",
          "Missing work + current grade are visible",
          "Output supports quick intervention action"
        ]
      },
      data: {
        requiredFields: [
          ["student_id","Unique student identifier","Y"],
          ["student_name","Full name","Y"],
          ["class","Course identifier","Y"],
          ["current_grade","Percent/letter","Y"],
          ["missing_assignments","Count missing","Y"],
          ["attendance_rate","Percent (optional)","N"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Grades/Missing","Gradebook CSV export","Teacher/Admin","Weekly"],
          ["Attendance","SIS export (optional)","Front Office","Weekly"]
        ],
        validityRules: [
          "current_grade must be numeric or mapped letter grade",
          "missing_assignments must be numeric",
          "If last_updated stale (>14 days) warn in production"
        ]
      },
      workflow: {
        states: [
          ["On Track","Grade>=80 and missing<=1"],
          ["At Risk","Grade 70–79 OR missing 2–3"],
          ["Critical","Grade<70 OR missing>=4"],
          ["Intervention Started","Action assigned"],
          ["Resolved","Back on track"]
        ],
        triggers: [
          ["At Risk","Meets At Risk rule","Add to list"],
          ["Critical","Meets Critical rule","Notify advisor"],
          ["Stale Data","Old export","Prompt refresh"]
        ],
        ownership: [
          ["Initial action","Teacher","Advisor if Critical"],
          ["Escalation","Advisor/Dean","School leadership"],
          ["Final authority","School leadership","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Weekly export (proof)"],
          ["Privacy sensitivity","High"],
          ["Access","Authorized staff only"]
        ],
        nonGoals: [
          "No student prediction/profiling",
          "No automated discipline actions",
          "No SIS integrations in v1"
        ]
      }
    })
  },

  "Non-profits": {
    id: "nonprofits",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a donor transparency dashboard for nonprofit admins so they can see overdue acknowledgments and reporting bottlenecks.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a dashboard listing overdue acknowledgments and program totals.",
      realityTest: "A staff member can open it and see what’s overdue in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": NONPROFITS_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": NONPROFITS_PROOF_APP_JS,
      "data/donations.csv": NONPROFITS_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Nonprofit teams lack consistent visibility into donor ops follow-ups and program reporting bottlenecks.",
        primaryUser: "Nonprofit Admin",
        secondaryUsers: "Ops, Program Lead",
        artifactType: "Dashboard",
        description: "Flag overdue donor acknowledgments and summarize program totals from CSV.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Overdue definition is explicit",
          "Overdue items are listed immediately",
          "Program totals are summarized",
          "Owner accountability is visible"
        ]
      },
      data: {
        requiredFields: [
          ["donation_id","Unique donation ID","Y"],
          ["program","Program bucket","Y"],
          ["amount","Donation amount","Y"],
          ["status","Received/Pending","Y"],
          ["days_to_ack","Days to acknowledge","Y"],
          ["owner","Responsible owner","Y"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Donations","CRM/export CSV","Admin","Weekly"]
        ],
        validityRules: [
          "amount and days_to_ack must be numeric",
          "status must be Received or Pending",
          "Define SLA for acknowledgments (ex: 7 days)"
        ]
      },
      workflow: {
        states: [
          ["Received","Donation received"],
          ["Acknowledgment Due","SLA clock running"],
          ["Overdue","Past SLA"],
          ["Resolved","Acknowledged and logged"]
        ],
        triggers: [
          ["Overdue","status==Received AND days_to_ack>7","Escalate list"]
        ],
        ownership: [
          ["Initial action","Admin","Program lead if needed"],
          ["Escalation","Ops lead","Executive Director"],
          ["Final authority","Executive Director","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Weekly export (proof)"],
          ["Privacy sensitivity","Medium"],
          ["Audit","Keep acknowledgment trail"]
        ],
        nonGoals: [
          "No fundraising strategy automation",
          "No payment processing integration in v1",
          "No donor segmentation in proof"
        ]
      }
    })
  },

  "Construction": {
    id: "construction",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a project bottleneck dashboard for PMs so they can see blocked tasks and cost variance at a glance.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a list of blocked tasks and a summary of variance and worst phases.",
      realityTest: "A PM can open it and see where the build is stuck in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": CONSTRUCTION_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": CONSTRUCTION_PROOF_APP_JS,
      "data/projects.csv": CONSTRUCTION_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Teams lack rapid visibility into blocked work and emerging cost variance, delaying intervention.",
        primaryUser: "Project Manager",
        secondaryUsers: "Foreman, Admin",
        artifactType: "Dashboard",
        description: "Rank blocked tasks by days blocked and summarize variance by project/phase.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Blocked definition is explicit",
          "Top blocked tasks are visible",
          "Variance is summarized",
          "Owner + next step are visible"
        ]
      },
      data: {
        requiredFields: [
          ["task_id","Unique task ID","Y"],
          ["project","Project/site name","Y"],
          ["phase","Build phase","Y"],
          ["status","Blocked/In Progress/etc","Y"],
          ["days_blocked","Days blocked","Y"],
          ["cost_variance","Variance amount","Y"],
          ["owner","Responsible owner","Y"],
          ["next_step","Immediate next step","Y"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Tasks/variance","PM tool export (CSV)","PM","Weekly"]
        ],
        validityRules: [
          "days_blocked and cost_variance must be numeric",
          "status must be standardized (Blocked/In Progress/etc)"
        ]
      },
      workflow: {
        states: [
          ["On Track","No block"],
          ["Blocked","Work stopped"],
          ["Escalated","Block > threshold"],
          ["Resolved","Unblocked and proceeding"]
        ],
        triggers: [
          ["Escalate","status==Blocked AND days_blocked>=5","PM escalation"]
        ],
        ownership: [
          ["Initial action","Foreman/PM","PM escalation"],
          ["Escalation","PM","Leadership"],
          ["Final authority","Leadership","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Weekly export (proof)"],
          ["Security sensitivity","Medium"],
          ["Documentation","Compliance docs linkable in production"]
        ],
        nonGoals: [
          "No scheduling engine",
          "No procurement automation in proof",
          "No integrations in v1"
        ]
      }
    })
  },

  "Small Business": {
    id: "small_business",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a pipeline dashboard for small business owners so they can see stalled deals and the next action required.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a list of stalled deals and a summary of value by stage.",
      realityTest: "An owner can open it and know what to do next in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": SMALLBIZ_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": SMALLBIZ_PROOF_APP_JS,
      "data/leads.csv": SMALLBIZ_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Small businesses lack consistent visibility into stalled pipeline and follow-up actions.",
        primaryUser: "Owner / Sales Lead",
        secondaryUsers: "Sales team",
        artifactType: "Dashboard",
        description: "Flag stalled deals by days-in-stage and summarize pipeline value from CSV.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Stalled definition is explicit",
          "Top stalled deals are visible",
          "Next action is listed",
          "Value exposure is summarized"
        ]
      },
      data: {
        requiredFields: [
          ["lead_id","Unique lead ID","Y"],
          ["company","Company name","Y"],
          ["stage","Pipeline stage","Y"],
          ["days_in_stage","Days in current stage","Y"],
          ["deal_value","Deal value","Y"],
          ["owner","Responsible owner","Y"],
          ["next_action","Immediate next step","Y"],
          ["last_updated","Freshness marker","Y"]
        ],
        sources: [
          ["Leads","CRM export (CSV)","Sales","Weekly"]
        ],
        validityRules: [
          "deal_value and days_in_stage must be numeric",
          "Define 'stalled' threshold (default 7 days)"
        ]
      },
      workflow: {
        states: [
          ["Active","Within SLA"],
          ["Stalled","Past SLA"],
          ["Escalated","High value stalled"],
          ["Resolved","Moved forward/closed"]
        ],
        triggers: [
          ["Stalled","days_in_stage>=7","Add to list"],
          ["High Value Stalled","deal_value>=threshold","Escalate"]
        ],
        ownership: [
          ["Initial action","Sales owner","Owner escalation"],
          ["Escalation","Owner","—"],
          ["Final authority","Owner","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Weekly export (proof)"],
          ["Security sensitivity","Low/Medium"],
          ["Simplicity","No CRM integration in v1"]
        ],
        nonGoals: [
          "No email automation in proof",
          "No forecasting",
          "No deep CRM customization"
        ]
      }
    })
  },

  "Supply Chain": {
    id: "supply_chain",
    defaultArtifact: "dashboard",
    example: {
      oneSentence: "I want to build a delay visibility dashboard for operations managers so they can see late shipments and bottlenecks instantly.",
      constraint: "I will build the first proof in 0.1 hours using static GitHub Pages files and a CSV export.",
      output: "The proof is done when it produces a dashboard ranking late shipments and summarizing delay drivers.",
      realityTest: "A stranger can open it and understand the bottleneck in under 60 seconds."
    },
    proofRepo: () => ({
      "index.html": SUPPLYCHAIN_PROOF_INDEX_HTML,
      "styles.css": BASE_PROOF_STYLES_CSS,
      "app.js": SUPPLYCHAIN_PROOF_APP_JS,
      "data/shipments.csv": SUPPLYCHAIN_PROOF_CSV
    }),
    sotDefaults: () => ({
      definition: {
        problem: "Operations teams lack timely visibility into shipment delays and their root causes, resulting in reactive decision-making.",
        primaryUser: "Operations Manager",
        secondaryUsers: "Procurement, Logistics Coordinator",
        artifactType: "Dashboard",
        description: "Surface late shipments and delay drivers (supplier/carrier/warehouse) from a CSV export.",
        timeToUnderstand: "< 60 seconds",
        doneCriteria: [
          "Primary user can identify late shipments without explanation",
          "Delay responsibility (handoff point) is visible",
          "Refresh cadence is stated and consistent",
          "No interpretation required to act"
        ]
      },
      data: {
        requiredFields: [
          ["shipment_id","Unique shipment identifier","Y"],
          ["po","PO reference","Y"],
          ["carrier","Carrier","Y"],
          ["supplier","Supplier","Y"],
          ["status","Status","Y"],
          ["planned_delivery","Planned delivery date","Y"],
          ["actual_delivery","Actual delivery date (optional)","N"],
          ["handoff_point","Responsibility category","Y"]
        ],
        sources: [
          ["Shipments","ERP/TMS export","Ops","Daily"],
          ["Status","Carrier export","Logistics","Daily"]
        ],
        validityRules: [
          "planned_delivery must be valid date",
          "Late = planned < today AND not delivered",
          "If CSV fails, show visible error (no silent failure)"
        ]
      },
      workflow: {
        states: [
          ["On Track","Planned delivery still in future"],
          ["At Risk","Delivery within 24h and status uncertain"],
          ["Delayed","Past planned date and not delivered"],
          ["Escalated","Past threshold requiring attention"],
          ["Resolved","Delivered and closed"]
        ],
        triggers: [
          ["Delay Detected","> 24h late","Flag on dashboard"],
          ["Critical Delay","> 72h late","Notify ops owner"],
          ["Repeated Supplier Delays","> 3 late shipments/week","Trigger supplier review"]
        ],
        ownership: [
          ["Initial triage","Logistics Coordinator","Ops Manager if unresolved"],
          ["Escalation","Operations Manager","Head of Ops"],
          ["Final authority","Head of Ops","—"]
        ]
      },
      constraints: {
        ops: [
          ["Refresh cadence","Daily export (proof); automate later"],
          ["Security sensitivity","Medium"],
          ["Availability","Mobile + desktop"]
        ],
        nonGoals: [
          "No forecasting in proof",
          "No automated penalties",
          "No deep integrations in v1"
        ]
      }
    })
  }
};
